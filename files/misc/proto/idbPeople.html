<html>
    <head>
        <style>
            table {
                border-collapse: collapse;
            }

            th, td {
                border: 1px solid black;
                box-sizing: border-box;
                padding: 4px;
            }

            .pointer {
                cursor: pointer;
            }

            table.people {
                display: inline-block;
                margin-right: 40px;
                vertical-align: top;
            }

            #add-form {
                display: inline-block;
                vertical-align: top;
            }
        </style>
    </head>
    <body>
        <div id="container"></div>
        <p>indexed db testing</p>
        <table class="people">
            <thead>
                <th>id</th>
                <th>name</th>
                <th>number</th>
            </thead>
            <tbody id="table"></tbody>
        </table>
        <div id="add-form">
            <p>Add a row</p>
            <input data-key="name" placeholder="name" /> <br />
            <input data-key="number" placeholder="number" /> <br />
            <button>add</button>
        </div>
    </body>
</html>
<script src="/misc/file/proto/idb.js"></script>
<script>

    /*
    todo

    - refactor idb to be dynamic
    - populate idb instance with id, name, number schema and data
    - complete idb class for basic CRUD
    
    */

    let table = document.getElementById("table");

    const createTable = async () => {
        let data = await personDbh.getPeople();
        table.innerHTML = data.map(row => `<tr>
            <td><span class="del pointer" title="Delete">[x]</span> ${row.id}</td>
            <td class="update pointer" data-key="name" title="Edit">${row.name}</td>
            <td class="update pointer" data-key="number" title="Edit">${row.number}</td>
        </tr>`).join("");

        // bind delete
        Array.from(table.querySelectorAll(".del")).forEach(del => {
            del.addEventListener("click", () => {
                let id = del.nextSibling.textContent.replace(/\s/g, "");
                personDbh.removePeople(id).then(() => createTable());
            });
        });

        // bind update
        Array.from(table.querySelectorAll(".update")).forEach(el => {
            el.addEventListener("click", () => {
                let id = el.parentElement.querySelector(".del").nextSibling.textContent.replace(/\s/g, "");
                let current = Array.from(el.parentElement.children).reduce((obj, child) => {
                    let key = child.dataset["key"];
                    if (key) {
                        obj[key] = child.innerText;
                    }

                    return obj;
                }, {id: id});
                let newValue = prompt(`New value for ${el.dataset["key"]}`, el.innerText);
                if (!newValue) {
                    newValue = el.innerText;
                }
                
                current[el.dataset["key"]] = newValue;
                personDbh.updatePeople(current).then(() => createTable());
            });
        });
    };

    // button bindings
    let addForm = document.getElementById("add-form");
    let submit = addForm.querySelector("button");
    submit.addEventListener("click", () => {
        let newData = Array.from(addForm.querySelectorAll("input")).reduce((obj, input) => {
            obj[input.dataset["key"]] = input.value;
            input.value = "";
            return obj;
        }, {});

        if (!newData.name || !newData.number) {
            throw new Error("missing data");
        }

        personDbh.addPeople(newData).then(() => createTable());
    });

    // db related
    // supply db name and version
    let dbname = "testing";
    let dbver = 1;
    // supply callback to create stores and indexes
    let upgrades = [
        db => {
            return new Promise(resolve => {
                let store = db.createObjectStore("people", { keypath: "id", autoIncrement: true });
                store.createIndex("name", "name", { unique: false });

                store.transaction.oncomplete = event => {
                    this.db = db;
                    resolve();
                };
            });
        },
    ];

    // database interface for person operations
    class PersonDBI {
        constructor(dbh) {
            this.dbh = dbh;
        }

        // static functions
        // give upgrade functions
        static schema () {
            return [
                db => {
                    return new Promise(resolve => {
                        let store = db.createObjectStore("people", { keypath: "id", autoIncrement: true });
                        store.createIndex("name", "name", { unique: false });

                        store.transaction.oncomplete = event => {
                            this.db = db;
                            resolve();
                        };
                    });
                },
            ];
        }

        // instance db functions
        getPeople () {
            let store = this.dbh.getStore("people", "readonly");
            return new Promise(resolve => {
                let items = [];
                // grab all data from table
                store.openCursor().onsuccess = event => {
                    let cursor = event.target.result;
                    if (cursor) {
                        items.push( Object.assign(cursor.value, { id: cursor.primaryKey }) );
                        cursor.continue();
                    } else {
                        resolve(items);
                    }
                };
            });
        }

        // utilizing a convenience method in IDBH
        // can add a single entry or a collection
        addPeople (data) {
            return this.dbh.add("people", Array.isArray(data) ? data : [data]);
        }

        // remove any number of peoples
        removePeople (data) {
            return new Promise(resolve => {
                let tx = this.dbh.getTransaction(["people"], "readwrite");
                tx.oncomplete = resolve;

                let store = tx.objectStore("people");
                data = Array.isArray(data) ? data : [data];
                data.forEach(datum => store.delete(Number(datum)));
            });
        }

        updatePeople (data) {
            return new Promise(resolve => {
                let tx = this.dbh.getTransaction(["people"], "readwrite");
                tx.oncomplete = resolve;

                data = Array.isArray(data) ? data : [data];
                data.forEach(obj => {
                    let key = Number(obj.id);
                    delete obj.id;
                    
                    tx.objectStore("people").put(obj, key);
                });
            });
        }
    }

    // instantiate handle, open db, add a people, log done
    let dbh = new IDBH(dbname, dbver, upgrades);
    let personDbh = new PersonDBI(dbh);
    dbh.open().then(() => createTable());

</script>