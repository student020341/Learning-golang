<style>
    body {
        margin: 0;
    }

    canvas {
        outline: 1px solid black;
        width: 800;
        height: 600;
    }
</style>
<div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <div>
        <p>FPS: <span id="fps"></span></p>
        <p>Discarded Frames: <span id="lag">0</span></p>
        <p id="debug"></p>
    </div>
</div>
<script>

/*
stuff
    left mouse - time stuff, mouse down to start path, release mouse to execute? - working well enough
    right mouse - dash - working well enough
    networking - current
    tag - to be done last

*/

var stuff = {};

init();
function init() {
    // vars and bindings and stuff
    stuff.canvas = document.getElementById("canvas");
    stuff.context = canvas.getContext("2d");
    stuff.fps = document.getElementById("fps");
    stuff.cLag = document.getElementById("lag");
    stuff.debug = document.getElementById("debug");

    stuff.stats = {
        frameSamples: [],
        fps: 0,
        debug: {}
    };

    stuff.speeds = {
        walk: 500, // 8 pixels per second
        focus: 0,
        fixed: 700, // 11 pixels per second
        dash: 900, // 15 pixels per second
    };

    stuff.limits = {
        stamina: 0.5,
        focus: 5
    };

    // time freeze thing
    stuff.gameFrozen = () => stuff.player.state == "focus";

    // resource regenerators
    stuff.staggers = {
        stamina: null,
        focus: null,
    };

    // player stuff
    stuff.player = {
        // player id
        id: null,
        // websocket
        ws: null,
        // current position
        position: {x: 0, y: 0},
        // target position
        target: {x: 0, y: 0},
        radius: 16,
        // hardware lag
        cLag: 0,
        // movement state
        state: "walk",
        // path for special thing
        timePath: [],
        // is this player it?
        tagged: false,
        stamina: stuff.limits.stamina,
        focus: stuff.limits.focus
    };

    // holds left (0) and right (2) pressed state
    stuff.mouseState = {};

    // event bindings
    playerBinding();

    // level
    setMaps();
    stuff.walls = stuff.levels[1];

    loop();
}

function playerMouseLogic (event) {
    const {clientX: x, clientY: y} = event;
    stuff.player.target = {x: x, y: y};
}

function playerBinding () {
    // disable right click
    document.addEventListener("contextmenu", e => {
        e.preventDefault();
    })
    // add mouse move
    stuff.canvas.addEventListener("mousemove", playerMouseLogic);
    // mouse buttons
    document.addEventListener("mousedown", e => {
        e.preventDefault();
        e.stopPropagation();
        stuff.mouseState[e.button] = 1;
    });
    document.addEventListener("mouseup", e => {
        e.preventDefault();
        e.stopPropagation();
        stuff.mouseState[e.button] = 0;
    });
}

// a random algorithm taken from stack overflow
function doesLineInterceptCircle(A, B, C, radius) {
    var dist;
    const v1x = B.x - A.x;
    const v1y = B.y - A.y;
    const v2x = C.x - A.x;
    const v2y = C.y - A.y;
    // get the unit distance along the line of the closest point to
    // circle center
    const u = (v2x * v1x + v2y * v1y) / (v1y * v1y + v1x * v1x);

    // if the point is on the line segment get the distance squared
    // from that point to the circle center
    if(u >= 0 && u <= 1){
        dist  = (A.x + v1x * u - C.x) ** 2 + (A.y + v1y * u - C.y) ** 2;
    } else {
        // if closest point not on the line segment
        // use the unit distance to determine which end is closest
        // and get dist square to circle
        dist = u < 0 ?
                (A.x - C.x) ** 2 + (A.y - C.y) ** 2 :
                (B.x - C.x) ** 2 + (B.y - C.y) ** 2;
    }
    return dist < radius * radius;
}

function getDirection (p1, p2, length) {
    let dx = p2.x - p1.x;
    let dy = p2.y - p1.y;

    length = isNaN(length) ? getDist(p1, p2) : length;

    return { x: dx/length, y: dy/length };
}

function getDist (p1, p2) {
    let dx = p2.x - p1.x;
    let dy = p2.y - p1.y;
    return Math.sqrt( (dx ** 2) + (dy ** 2) );
}

function draw () {
    const c = stuff.context;

    // clear area
    c.clearRect(0, 0, 800, 600)

    // draw player
    c.beginPath();
    c.arc(stuff.player.position.x, stuff.player.position.y, stuff.player.radius, 0, Math.PI*2);
    c.stroke();

    // draw player status
    // stamina bar!
    if (stuff.player.stamina != stuff.limits.stamina) {
        c.fillStyle = `rgba(0, 128, 0, 0.8)`;
        let w = (stuff.player.stamina / stuff.limits.stamina) * 40;
        w = w < 4 ? 4 : w;
        c.fillRect(stuff.player.position.x-16, stuff.player.position.y-30, w, 10);
    }

    // focus / time bar!
    if (stuff.player.focus != stuff.limits.focus) {
        c.fillStyle = `rgba(128, 0, 0, 0.8)`;
        let w = (stuff.player.focus / stuff.limits.focus) * 40;
        w = w < 4 ? 4 : w;
        c.fillRect(stuff.player.position.x-16, stuff.player.position.y+10, w, 10);
    }

    // focus / time path!
    if (stuff.player.timePath.length > 0) {
        c.strokeStyle = `rgba(128, 0, 0, 0.8)`;
        // draw line from player to first point
        c.beginPath();
        c.moveTo(stuff.player.position.x, stuff.player.position.y);
        c.lineTo(stuff.player.timePath[0].x, stuff.player.timePath[0].y);
        c.stroke();

        // draw lines between successive points
        c.beginPath();
        c.moveTo(stuff.player.timePath[0].x, stuff.player.timePath[0].y);
        for (let i = 1;i < stuff.player.timePath.length-1;i++) {
            c.lineTo(stuff.player.timePath[i].x, stuff.player.timePath[i].y);
        }
        c.stroke();
        // draw player outline at points
        stuff.player.timePath.forEach(point => {
            c.beginPath();
            c.arc(point.x, point.y, stuff.player.radius, 0, Math.PI*2);
            c.stroke();
        });
    }

    c.fillStyle = `black`;
    c.strokeStyle = 'black';

    // draw level geometry
    stuff.walls.forEach(line => {
        c.beginPath();
        c.moveTo(line.p1.x, line.p1.y);
        c.lineTo(line.p2.x, line.p2.y);
        c.stroke();
    });

    // draw effects
}

// mouse buttons and move state
function mouseStep (dt) {
    // vars!
    const wantToDash = stuff.mouseState[2];
    const wantToFocus = stuff.mouseState[0];
    const canDash = stuff.player.stamina > 0;
    const canFocus = stuff.player.focus > 0;
    const currentState = stuff.player.state;
    let havePathPoints = stuff.player.timePath.length > 0;

    stuff.stats.debug["player state"] = stuff.player.state;
    stuff.stats.debug["want to focus"] = wantToFocus;
    stuff.stats.debug["can focus"] = canFocus;
    stuff.stats.debug["focus"] = stuff.player.focus;

    // stagger mini functions
    const _cancelStaminaStagger = () => {
        if (stuff.staggers.stamina) {
            clearTimeout(stuff.staggers.stamina);
        }
    };
    const _beginStaminaStagger = () => {
        _cancelStaminaStagger();
        stuff.staggers.stamina = setTimeout(() => {
            stuff.player.stamina = stuff.limits.stamina;
        }, (stuff.limits.stamina+1)*1000);
    };
    const _cancelFocusStagger = () => {
        if (stuff.staggers.focus) {
            clearTimeout(stuff.staggers.focus);
        }
    };
    const _beginFocusStagger = () => {
        _cancelFocusStagger();
        stuff.staggers.focus = setTimeout(() => {
            stuff.player.focus = stuff.limits.focus;
        }, (stuff.limits.focus + 1)*1000);
    };

    // transition to dash
    if (canDash && wantToDash && currentState != "dash") {
        if (havePathPoints || currentState == "focus") {
            havePathPoints = false;
            stuff.player.timePath = [];
            _beginFocusStagger();
        }
        stuff.player.state = "dash";
        // stop current stamina regen if player resumes dash
        _cancelStaminaStagger();
    }

    // reduce player stamina if they are dashing
    if (stuff.player.state == "dash") {
        stuff.player.stamina -= dt;
    }

    // end dash
    let shouldEndDash = stuff.player.stamina <= 0 && stuff.player.state == "dash";
    let stoppedDashing = !wantToDash && stuff.player.state == "dash";
    if ( shouldEndDash || stoppedDashing ) {
        stuff.player.state = "walk";
        _beginStaminaStagger();
    }

    // transition to focus
    if (wantToFocus && canFocus && stuff.player.state != "focus") {
        if (stuff.player.currentState == "dash") {
            _beginStaminaStagger();
        }
        if (havePathPoints) {
            stuff.player.timePath = [];
            havePathPoints = false;
        }
        stuff.player.state = "focus";
        _cancelFocusStagger();
    }

    if (stuff.player.state == "focus") {
        stuff.player.focus -= dt;
    }

    // end focus, forced
    if (stuff.player.state == "focus" && stuff.player.focus <= 0) {
        stuff.player.state = "walk";
        stuff.player.timePath = [];
        _beginFocusStagger();
    }

    // create fixed path
    if (stuff.player.state == "focus" && wantToFocus) {
        if (stuff.player.timePath.length < 1) {
            stuff.player.timePath.push(stuff.player.target);
        } else {
            const prev = stuff.player.timePath[ stuff.player.timePath.length-1 ];
            const dist = getDist(prev, stuff.player.target);
            if (dist > 20) {
                stuff.player.timePath.push(stuff.player.target);
            }
        }
    }

    // end focus, release
    if (canFocus && stuff.player.state == "focus" && !wantToFocus && havePathPoints) {
        stuff.player.state = "fixed";
    }

    if (stuff.player.state == "fixed" && !havePathPoints) {
        stuff.player.state = "walk";
        _beginFocusStagger();
    }
}

function step (dt) {

    // state logic, mouse button logic
    mouseStep(dt);

    let havePathPoints = () => stuff.player.timePath.length > 0;
    let followingMouse = !(stuff.player.state == "fixed" && havePathPoints());
    const pos = stuff.player.position;
    const target = followingMouse ? stuff.player.target : stuff.player.timePath[0];

    let dist = getDist(pos, target);
    let dir = getDirection(pos, target, dist);

    // invalid target or 0 length
    if (isNaN(dir.x) || isNaN(dir.y)) {
        return;
    }

    let newPos = Object.assign({}, pos);
    if (dist <= stuff.player.radius && stuff.player.state != "fixed") { return; }
    let mx = dir.x * dt * stuff.speeds[stuff.player.state];
    let my = dir.y * dt * stuff.speeds[stuff.player.state];
    // constrain maximmum movement deltas to 15 units - minor glitch the framerate doesn't always account for
    if (Math.abs(mx) > 15) {
        mx = Math.sign(mx) * 15;
    }
    if (Math.abs(my) > 15) {
        my = Math.sign(my) * 15;
    }
    newPos.x += mx;
    newPos.y += my;
    

    // collision with level
    let collisionWithLevel = [
        // just X
        stuff.walls.some(line => doesLineInterceptCircle(line.p1, line.p2, {x: newPos.x, y: pos.y}, stuff.player.radius)),
        // just Y
        stuff.walls.some(line => doesLineInterceptCircle(line.p1, line.p2, {x: pos.x, y: newPos.y}, stuff.player.radius)),
    ];

    if (!collisionWithLevel[0] && !collisionWithLevel[1]) {
        pos.x = newPos.x;
        pos.y = newPos.y;
    } else if (collisionWithLevel[0] && !collisionWithLevel[1]) {
        pos.y = newPos.y;
    } else if (!collisionWithLevel[0] && collisionWithLevel[1]) {
        pos.x = newPos.x;
    }

    // traversing path
    if (!followingMouse) {
        const dist = getDist(stuff.player.position, target);
        if (dist <= 16) {
            pos.x = target.x;
            pos.y = target.y;
            stuff.player.timePath.shift();
        }
    }
}

async function loop () {
    const lowerLimit = 1/60;
    while(true) {
        let t2 = performance.now();
        let p = new Promise(resolve => requestAnimationFrame(t1 => {
            // time delta
            let dt = (t1 - t2)/1000;
            // I don't know if the browser is lying or what, but cap to 60fps
            if (dt < lowerLimit) {
                dt = lowerLimit;
            }
            updateFrameSamples(dt);
            stuff.fps.innerText = stuff.stats.fps;
            // do not interpolate latency greater than 1 second
            if (dt > 1) {
                stuff.player.cLag++;
                stuff.cLag.innerText = stuff.player.cLag;
                resolve();
                return;
            }

            // debug
            stuff.debug.innerText = Object.keys(stuff.stats.debug).reduce((str, key) => `${str}\n${key}: ${stuff.stats.debug[key]}`, "");

            draw();
            step(dt);
            
            resolve();
        }));
        
        await p;
    }
}

// ugly stuff beyond this point

function updateFrameSamples (dt) {
    stuff.stats.frameSamples.push(dt);
    if (stuff.stats.frameSamples.length > 60) {
        stuff.stats.frameSamples.shift();
    }
    stuff.stats.fps = (1/(stuff.stats.frameSamples.reduce((sum, num) => sum+num, 0) / stuff.stats.frameSamples.length)).toPrecision(5);
}

function setMaps () {
    stuff.levels = [
        // stage 1 - big empty area
        [],
        // stage 2 - plus in the middle of the stage
        [
            {
                p1: {x: 200, y: 300},
                p2: {x: 600, y: 300}
            },
            {
                p1: {x: 400, y: 200},
                p2: {x: 400, y: 400} 
            }
        ],
        // stage 3 - complicated maze thing
        [
            // center plus
            {
                p1: {x: 200, y: 300},
                p2: {x: 600, y: 300}
            },
            {
                p1: {x: 400, y: 200},
                p2: {x: 400, y: 400} 
            },
            // line left of center plus
            {
                p1: {x: 200, y: 340},
                p2: {x: 360, y: 340}
            },
            {
                p1: {x: 360, y: 340},
                p2: {x: 360, y: 400}
            },
            // line right of center plus
            {
                p1: {x: 440, y: 260},
                p2: {x: 600, y: 260}
            },
            {
                p1: {x: 440, y: 260},
                p2: {x: 440, y: 200}
            },
            // top right corner thing
            {
                p1: {x: 500, y: 50},
                p2: {x: 500, y: 200}
            },
            {
                p1: {x: 500, y: 200},
                p2: {x: 750, y: 200}
            },
            // bottom left x
            {
                p1: {x: 50, y: 400},
                p2: {x: 200, y: 550}
            },
            {
                p1: {x: 200, y: 400},
                p2: {x: 50, y: 550}
            },
            // top left corner maze
            {
                p1: {x: 50, y: 50},
                p2: {x: 100, y: 50}
            },
            {
                p1: {x: 150, y: 50},
                p2: {x: 300, y: 50}
            },
            {
                p1: {x: 50, y: 50},
                p2: {x: 50, y: 260}
            },
            {
                p1: {x: 50, y: 260},
                p2: {x: 250, y: 260}
            },
            {
                p1: {x: 300, y: 260},
                p2: {x: 300, y: 50}
            },
            // bottom right corner maze
            {
                p1: {x: 750, y: 400},
                p2: {x: 750, y: 550}
            },
            {
                p1: {x: 450, y: 400},
                p2: {x: 450, y: 550}
            },
            {
                p1: {x: 450, y: 400},
                p2: {x: 570, y: 400}
            },
            {
                p1: {x: 630, y: 400},
                p2: {x: 750, y: 400}
            },
            {
                p1: {x: 500, y: 450},
                p2: {x: 700, y: 450}
            },
            {
                p1: {x: 500, y: 450},
                p2: {x: 500, y: 500}
            },
            {
                p1: {x: 700, y: 450},
                p2: {x: 700, y: 475}
            },
            {
                p1: {x: 700, y: 475},
                p2: {x: 750, y: 475}
            },
            {
                p1: {x: 500, y: 540},
                p2: {x: 500, y: 550}
            },
            {
                p1: {x: 450, y: 550},
                p2: {x: 675, y: 550}
            },
            {
                p1: {x: 725, y: 550},
                p2: {x: 750, y: 550}
            },
            {
                p1: {x: 500, y: 540},
                p2: {x: 540, y: 540}
            },
            {
                p1: {x: 540, y: 540},
                p2: {x: 540, y: 490}
            },
            {
                p1: {x: 580, y: 450},
                p2: {x: 580, y: 510}
            },
            {
                p1: {x: 650, y: 550},
                p2: {x: 650, y: 500}
            },
        ]
    ];
}

</script>