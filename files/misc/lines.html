<style>
	body {
		margin: 0;
	}
</style>
<div>
    <div id="container"></div>
	<div>
		<label>Rotation Y axis</label>
		<input type="range" min="0" max="6.28319" value="0" step="0.1" id="rotY" />
	</div>
	<div>
		<label>Rotation X axis</label>
		<input type="range" min="0" max="6.28319" value="0" step="0.1" id="rotX" />
	</div>
</div>
<script src="/misc/file/three.min.js"></script>
<script>

let domNodes = {
    fps: document.getElementById("fps"),
    container: document.getElementById("container"),
};

// threejs stuff
var scene, camera, renderer;
// point debugs
var lines = [];

// initialization
init();
function init() 
{
	/*
	NOTE: most of this code is boilerplate stripped from a hello world example to get the lights, rendering, materials, etc.
	*/
	scene = new THREE.Scene();
	
	// set the view size in pixels (custom or according to window size)
	var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 300;	
	// camera attributes
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 1, FAR = 2000;
	// set up camera
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	// add the camera to the scene
	scene.add(camera);
	// camera.position.set(0,0,50);
	camera.position.set(0,0,20);
	
	// create and start the renderer; choose antialias setting.
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	
	// attach renderer to the container div
	domNodes.container.appendChild( renderer.domElement );

    const vec3 = THREE.Vector3;

	// target line
	lines.push(simpleLine([
		new vec3(0, 0, 0),
		new vec3(5, 10, 10)
    ]));

    lines.push(simpleLine([
        new vec3(0, 0, 0),
        new vec3(-5, 0, 0)
    ], "red"));
    
    lines.forEach(line => scene.add(line));
	
	// fog must be added to scene before first render
    scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );
    
    loop();

	// inputs / debug
	document.getElementById("rotY").addEventListener("input", (e) => {
        lines.forEach(line => line.rotation.y = e.target.value);
	});
    document.getElementById("rotX").addEventListener("input", e => {
        lines.forEach(line => line.rotation.x = e.target.value);
	});
}

function simpleLine (points, color = 0xffffff) {
    let material = new THREE.LineBasicMaterial({
        color: color
    });

    let geometry = new THREE.Geometry();
    geometry.vertices.push(...points);

    return new THREE.Line(geometry, material);
}

function pointOnSphere (radius, theta, phi) {
    let x = radius * Math.sin(phi) * Math.cos(theta);
    let y = radius * Math.sin(phi) * Math.sin(theta);
    let z = radius * Math.cos(phi);

    return [x, y, z].map(f => parseFloat(f.toFixed(8)));
}

async function loop () {
    while(true) {
        let t2 = performance.now();
        let p = new Promise(resolve => requestAnimationFrame(t1 => {
            // time delta
            let dt = (t1 - t2)/1000;
            // do not interpolate latency greater than 1 second
            if (dt > 1) {
                resolve();
                return;
            }

            renderer.render(scene, camera);
            resolve();
        }));
        
        await p;
    }
}

</script>
