<style>
	body {
		margin: 0;
	}
</style>
<div>
    <div id="container"></div>
	<div>
		<label>Rotation Y axis</label>
		<input type="range" min="0" max="6.28319" value="0" step="0.1" id="rotY" />
	</div>
	<div>
		<label>Rotation X axis</label>
		<input type="range" min="0" max="6.28319" value="0" step="0.1" id="rotX" />
	</div>
</div>
<script src="/misc/file/three.min.js"></script>
<script>

let domNodes = {
    container: document.getElementById("container"),
};

// threejs stuff
var scene, camera, renderer;
// point debugs
const vec3 = THREE.Vector3;
var lines = [];

// initialization
init();
function init() 
{
	/*
	NOTE: most of this code is boilerplate stripped from a hello world example to get the lights, rendering, materials, etc.
	*/
	scene = new THREE.Scene();
	
	// set the view size in pixels (custom or according to window size)
	var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 300;	
	// camera attributes
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 1, FAR = 2000;
	// set up camera
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	// add the camera to the scene
	scene.add(camera);
	// camera.position.set(0,0,50);
	camera.position.set(0,0,20);
	
	// create and start the renderer; choose antialias setting.
	renderer = new THREE.WebGLRenderer( {antialias:true} );
	
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	
	// attach renderer to the container div
	domNodes.container.appendChild( renderer.domElement );

	// line representing target rotation
	lines.push(simpleLine([
		new vec3(0, 0, 0),
		new vec3(5, 10, 10)
    ]));

    let resolution = 8;
    let radiansPer = (Math.PI*2)/resolution;
    createStandardLines(lines, resolution, radiansPer);
    horribleGuessLines(lines, resolution, radiansPer);
    
    lines.forEach(line => scene.add(line));
	
	// fog must be added to scene before first render
    scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );
    
    loop();

	// inputs / debug
	document.getElementById("rotY").addEventListener("input", (e) => {
        lines.forEach(line => line.rotation.y = e.target.value);
	});
    document.getElementById("rotX").addEventListener("input", e => {
        lines.forEach(line => line.rotation.x = e.target.value);
	});
}

function simpleLine (points, color = 0xffffff) {
    let material = new THREE.LineBasicMaterial({
        color: color
    });

    let geometry = new THREE.Geometry();
    geometry.vertices.push(...points);

    return new THREE.Line(geometry, material);
}

function pointOnSphere (radius, theta, phi) {
    let x = radius * Math.sin(phi) * Math.cos(theta);
    let y = radius * Math.sin(phi) * Math.sin(theta);
    let z = radius * Math.cos(phi);

    return [x, y, z].map(f => parseFloat(f.toFixed(8)));
}

function createStandardLines (lines, resolution, radiansPer) {
    // shape facing x+
    (() => {
        let points = [];
        for (let i = 0;i < resolution;i++) {
            let theta = -Math.PI/2;
            let phi = radiansPer * i;

            let [x, y, z] = pointOnSphere(4, theta, phi);
            
            points.push(new vec3(x, y, z));
        }
        points.push(points[0]);
        lines.push(simpleLine(points, 0xff0000));
        lines.push(simpleLine([
            new vec3(0, 0, 0),
            new vec3(10, 0, 0)
        ], 0xff0000));
    })();

    // shape facing y+
    (() => {
        let points = [];
        for (let i = 0;i < resolution;i++) {
            let theta = 0;
            let phi = radiansPer * i;

            let [x, y, z] = pointOnSphere(4, theta, phi);
            
            points.push(new vec3(x, y, z));
        }
        points.push(points[0]);
        lines.push(simpleLine(points, 0x00ff00));
        lines.push(simpleLine([
            new vec3(0, 0, 0),
            new vec3(0, 10, 0)
        ], 0x00ff00));
    })();

    // shape facing z+
    (() => {
        let points = [];
        for (let i = 0;i < resolution;i++) {
            let theta = radiansPer * i;
            let phi = Math.PI/2;

            let [x, y, z] = pointOnSphere(4, theta, phi);
            points.push(new vec3(x, y, z));
        }
        points.push(points[0]);
        lines.push(simpleLine(points, 0x0000ff));
        lines.push(simpleLine([
            new vec3(0, 0, 0),
            new vec3(0, 0, 10)
        ], 0x0000ff));
    })();
}

function horribleGuessLines (lines, resolution, radiansPer) {
    // iterate theta and phi because reasons
    (() => {
        let points = [];
        for (let i = 0;i < resolution;i++) {
            let theta = radiansPer * i;
            let phi = radiansPer * i;

            let [x, y, z] = pointOnSphere(4, theta, phi);
            
            points.push(new vec3(x, y, z));
        }
        points.push(points[0]);
        lines.push(simpleLine(points, 0x00ffff));
    })();
}

    // degrees => radians
function RadiansFrom (degrees) {
    return degrees * (Math.PI / 180);
}
    
    // radians => degrees
function DegreesFrom (radians) {
    return radians / (Math.PI / 180);
}

async function loop () {
    while(true) {
        let t2 = performance.now();
        let p = new Promise(resolve => requestAnimationFrame(t1 => {
            // time delta
            let dt = (t1 - t2)/1000;
            // do not interpolate latency greater than 1 second
            if (dt > 1) {
                resolve();
                return;
            }

            renderer.render(scene, camera);
            resolve();
        }));
        
        await p;
    }
}

</script>
